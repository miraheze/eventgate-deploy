// src/index.ts
import path from "node:path";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { loadConfig } from "c12";

// src/logging/index.ts
import winston from "winston";
import { ecsFields, ecsStringify } from "@elastic/ecs-winston-format";

// src/logging/wikimedia_ecs.ts
import { LEVEL, MESSAGE, SPLAT } from "triple-beam";
import { defu } from "defu";
var WikimediaEcsFormatMiddleware = class {
  transform(info) {
    const serviceInfo = this.processServiceName(info);
    const httpInfo = this.processHttpData(serviceInfo);
    const requestIdInfo = this.processRequestId(httpInfo);
    requestIdInfo[LEVEL] = info[LEVEL];
    requestIdInfo[MESSAGE] = info[MESSAGE];
    requestIdInfo[SPLAT] = info[SPLAT];
    return requestIdInfo;
  }
  /**
   * Handles service name transformation from legacy bunyan structure
   *
   * @param info
   */
  processServiceName(info) {
    if (!info.serviceName && !(info.service && typeof info.service !== "object")) {
      return info;
    }
    const serviceName = info.serviceName ?? info.service;
    const updatedInfo = { ...info };
    updatedInfo.service = { name: serviceName };
    delete updatedInfo.serviceName;
    return updatedInfo;
  }
  /**
   * Processes HTTP request and response data into ECS format
   * See https://github.com/wikimedia/service-template-node/blob/main/lib/util.js#L45
   *
   * @param info
   */
  processHttpData(info) {
    var _a;
    if (!info.request && !info.response) {
      return info;
    }
    const http = {};
    const url = {};
    const source = {};
    if (info.request) {
      const requestData = info.request;
      source.ip = requestData.remoteAddress;
      source.port = requestData.remotePort;
      url.full = requestData.url;
      url.path = ((_a = requestData.params) == null ? void 0 : _a[0]) ?? requestData.path ?? "";
      const { remoteAddress, remotePort, url: requestUrl, params, ...cleanRequest } = requestData;
      http.request = cleanRequest;
    }
    if (info.response) {
      http.response = info.response;
    }
    const { request, response, ...baseInfo } = info;
    return defu(baseInfo, {
      http,
      url,
      source,
      message: baseInfo.message,
      level: baseInfo.level
    });
  }
  /**
   * Handles request ID transformation
   *
   * @param info
   */
  processRequestId(info) {
    if (!info.requestId && !info.request_id) {
      return info;
    }
    const requestId = info.requestId ?? info.request_id;
    const http = { request: { id: requestId } };
    const { requestId: _, request_id: __, ...baseInfo } = info;
    return defu(baseInfo, {
      http,
      message: baseInfo.message,
      level: baseInfo.level
    });
  }
};
var wikimediaEcsFormatMiddleware = () => new WikimediaEcsFormatMiddleware();

// src/logging/index.ts
var logLevels = {
  fatal: 0,
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  verbose: 4,
  debug: 5,
  trace: 5,
  silly: 6
};
var createWinstonLogger = (serviceName, options = {}) => {
  options = {
    ...{
      level: "info",
      stacktrace: true,
      format: "ecs",
      transports: [{ transport: "Console" }]
    },
    ...options
  };
  const ecsFormatter = [
    ecsFields({ convertReqRes: true, ...options.formatOptions }),
    wikimediaEcsFormatMiddleware(),
    ecsStringify()
  ];
  return winston.createLogger({
    levels: logLevels,
    level: options.level,
    format: winston.format.combine(
      ...[
        // Enable stacktrace for errors
        winston.format.errors({ stack: options.stacktrace }),
        options.format === "ecs" ? ecsFormatter : winston.format[options.format ?? "json"](
          options.format ? options.formatOptions : void 0
        )
      ].flat()
    ),
    defaultMeta: {
      service: {
        name: serviceName
      },
      ...options.defaultMeta
    },
    transports: (options.transports ?? []).map(
      ({ transport, options: transportOptions }) => (
        // @ts-ignore
        new winston.transports[transport]({
          ...transportOptions,
          // Spread format seperately so we can add on options as parameters
          ...(transportOptions == null ? void 0 : transportOptions.format) ? {
            format: winston.format.combine(
              ...[
                winston.format.errors({ stack: options.stacktrace }),
                transportOptions.format === "ecs" ? ecsFormatter : winston.format[transportOptions.format](
                  transportOptions.formatOptions
                )
              ].flat()
            )
          } : {}
        })
      )
    )
  });
};

// src/index.ts
import Prometheus3 from "prom-client";

// src/metric/prometheus.ts
import Prometheus from "prom-client";
var normalize = (str) => String(str).replace(/\W/g, "_").replace(/_+/g, "_").replace(/(^_+|_+$)/g, "");
var PrometheusMetric = class {
  options;
  client;
  staticLabels;
  metric;
  constructor(options, client) {
    this.client = client;
    this.options = structuredClone(options);
    if (this.options.labels === void 0) {
      this.options.labels = { names: [] };
    }
    this.staticLabels = this.options.prometheus.staticLabels || {};
    Object.keys(this.staticLabels).forEach((labelName) => {
      var _a;
      (_a = this.options.labels) == null ? void 0 : _a.names.unshift(labelName);
    });
    this.options.labels.names = this.options.labels.names.map(normalize);
    this.options.prometheus.name = normalize(
      this.options.prometheus.name
    );
    this.metric = new this.client[this.options.type]({
      name: this.options.prometheus.name,
      help: this.options.prometheus.help,
      labelNames: this.options.labels.names,
      buckets: this.options.prometheus.buckets,
      percentiles: this.options.prometheus.percentiles
    });
  }
  /**
   * Gets label values array for this metric
   * including both static and dynamic labels merged together.
   *
   * @param {Array} labelValues
   * @return {Array}
   */
  _getLabelValues(labelValues) {
    const updatedLabelValues = [...labelValues];
    Object.keys(this.staticLabels).forEach((labelName) => {
      if (!updatedLabelValues.includes(this.staticLabels[labelName])) {
        updatedLabelValues.unshift(this.staticLabels[labelName]);
      }
    });
    return updatedLabelValues;
  }
  increment(amount, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    this.metric.labels.apply(this.metric, updatedLabelValues).inc(amount);
  }
  decrement(amount, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    this.metric.labels.apply(this.metric, updatedLabelValues).dec(amount);
  }
  observe(value, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    this.metric.labels.apply(this.metric, updatedLabelValues).observe(value);
  }
  gauge(amount, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    if (amount < 0) {
      this.metric.labels.apply(this.metric, updatedLabelValues).dec(Math.abs(amount));
    } else {
      this.metric.labels.apply(this.metric, updatedLabelValues).inc(amount);
    }
  }
  set(value, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    this.metric.labels.apply(this.metric, updatedLabelValues).set(value);
  }
  timing(value, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    this.observe(value, updatedLabelValues);
  }
  endTiming(startTime, labelValues) {
    const updatedLabelValues = this._getLabelValues(labelValues);
    this.timing((Date.now() - startTime) / 1e3, updatedLabelValues);
  }
};
var PrometheusClient = class {
  logger;
  client;
  constructor(logger) {
    this.logger = logger;
    this.client = Prometheus;
  }
  makeMetric(options) {
    return new PrometheusMetric(options, this.client);
  }
  close() {
  }
};

// src/metric/metric.ts
var Metric = class {
  type;
  metric;
  logger;
  constructor(client, logger, options) {
    this.type = options.type;
    this.logger = logger;
    this.metric = client.makeMetric(options);
  }
  increment(amount = 1, labels = []) {
    if (["Counter" /* COUNTER */, "Gauge" /* GAUGE */].includes(this.type)) {
      this.metric.increment(amount, labels);
    } else {
      this.logger.error(
        `increment() unsupported for metric type ${this.type}`,
        { levelPath: "error/metrics" }
      );
    }
  }
  decrement(amount = 1, labels = []) {
    if (this.type === "Gauge" /* GAUGE */) {
      this.metric.decrement(amount, labels);
    } else {
      this.logger.error(
        `decrement() unsupported for metric type ${this.type}`,
        { levelPath: "error/metrics" }
      );
    }
  }
  observe(value, labels = []) {
    if (["Histogram" /* HISTOGRAM */, "Summary" /* SUMMARY */].includes(this.type)) {
      this.metric.observe(value, labels);
    } else {
      this.logger.error(`observe() unsupported for metric type ${this.type}`, {
        levelPath: "error/metrics"
      });
    }
  }
  gauge(amount, labels = []) {
    if (this.type === "Gauge" /* GAUGE */) {
      this.metric.gauge(amount, labels);
    } else {
      this.logger.error(
        `set() or unique() unsupported for metric type ${this.type}`,
        { levelPath: "error/metrics" }
      );
    }
  }
  set(value, labels = []) {
    if (this.type === "Gauge" /* GAUGE */) {
      this.metric.set(value, labels);
    } else {
      this.logger.error(
        `set() or unique() unsupported for metric type ${this.type}`,
        { levelPath: "error/metrics" }
      );
    }
  }
  timing(value, labels = []) {
    if (this.type === "Histogram" /* TIMING */) {
      this.metric.timing(value, labels);
    } else {
      this.logger.error(`timing() unsupported for metric type ${this.type}`, {
        levelPath: "error/metrics"
      });
    }
  }
  endTiming(startTime, labels = []) {
    if (this.type === "Histogram" /* TIMING */) {
      this.metric.endTiming(startTime, labels);
    } else {
      this.logger.error(
        `endTiming() unsupported for metric type ${this.type}`,
        { levelPath: "error/metrics" }
      );
    }
  }
};

// src/metric/index.ts
var Metrics = class {
  options;
  client;
  prometheus;
  serviceName;
  cache;
  logger;
  constructor(serviceName, logger, options) {
    this.options = options;
    this.logger = logger;
    this.cache = /* @__PURE__ */ new Map();
    this.serviceName = serviceName;
    if (!options || options && options.type === "prometheus") {
      this.client = new PrometheusClient(
        this.logger
      );
      this.prometheus = this.client.client;
      return;
    }
    logger.error(
      `No such metrics client: '${options.type ?? "undefined"}'`
    );
  }
  getServiceName() {
    return this.serviceName;
  }
  // T247820: Selectively disable service label based on environment variable.
  // Intended for production use case where the service label will be set
  // by the Prometheus server.
  getServiceLabel() {
    if (process.env.METRICS_SERVICE_LABEL_ENABLED === "false") {
      return void 0;
    }
    return { service: this.serviceName };
  }
  /**
   * @deprecated Remnant from service-runner. Use Prometheus directly.
   */
  fetchClient() {
    return this.client;
  }
  /**
   * @deprecated Use {@link createMetric} for new projects.
   *
   * @param options
   * @return
   */
  makeMetric(options) {
    let metric = this.cache.get(options.name);
    if (metric === void 0) {
      metric = new Metric(this.client, this.logger, options);
      this.cache.set(options.name, metric);
    }
    return metric;
  }
  /**
   * Makes and returns a raw Prometheus Metric bypassing the service-runner wrapper.
   *
   * @param options
   * @return
   */
  createMetric(options) {
    var _a;
    const normalisedName = normalize(options.name);
    let metric = this.prometheus.register.getSingleMetric(normalisedName);
    if (metric) {
      return metric;
    }
    let labelNames = [normalisedName];
    if ((_a = options.labels) == null ? void 0 : _a.names) {
      labelNames = labelNames.concat(options.labels.names);
    }
    metric = new this.prometheus[options.type]({
      name: normalisedName,
      help: options.help,
      labelNames,
      buckets: options.buckets,
      percentiles: options.percentiles
    });
    this.prometheus.register.registerMetric(metric);
    return metric;
  }
  close() {
    this.client.close();
  }
};

// src/metric/prometheus_server.ts
import Prometheus2 from "prom-client";
import HTTP from "http";
var PrometheusServer = class {
  config;
  server;
  constructor(config, defaultLabels = { service: "default_service" }) {
    this.config = config;
    if (this.config.collectDefaultMetrics !== false) {
      Prometheus2.collectDefaultMetrics();
    }
    Prometheus2.register.setDefaultLabels(defaultLabels);
    this.server = HTTP.createServer(async (req, res) => {
      res.end(await Prometheus2.register.metrics());
    });
  }
  start() {
    this.server.listen(this.config.port);
  }
  async close() {
    Prometheus2.register.clear();
    this.server.close((err) => {
      Promise.resolve(err);
    });
  }
};

// src/express.ts
var wrapRouteHandlers = (app, metrics, subPath = "") => {
  const router = app._router ?? app;
  router.stack.flatMap((routerLayer) => routerLayer.route ? routerLayer : []).forEach((routerLayer) => {
    var _a, _b;
    const path2 = (subPath + "/" + ((_a = routerLayer.route) == null ? void 0 : _a.path.slice(1))).replace(/\/:/g, "/--").replace(/^\//, "").replace(/[/?]+$/, "");
    (_b = routerLayer == null ? void 0 : routerLayer.route) == null ? void 0 : _b.stack.forEach((layer) => {
      const origHandler = layer.handle;
      const metric = metrics.makeMetric({
        type: "Histogram" /* HISTOGRAM */,
        name: "router",
        prometheus: {
          name: "express_router_request_duration_seconds",
          help: "request duration handled by router in seconds",
          staticLabels: metrics.getServiceLabel(),
          buckets: [0.01, 0.05, 0.1, 0.3, 1]
        },
        labels: {
          names: ["path", "method", "status"],
          omitLabelNames: true
        }
      });
      layer.handle = async (req, res, next) => {
        const startTime = Date.now();
        try {
          await origHandler(req, res, next);
        } catch {
          await next();
        } finally {
          let statusCode = res.statusCode || 500;
          if (statusCode < 100 || statusCode > 599) {
            statusCode = 500;
          }
          metric.endTiming(startTime, [
            path2 || "root",
            req.method,
            statusCode.toString()
          ]);
        }
      };
    });
  });
};
var _replacePathWithPlaceholders = (path2, params = []) => {
  if (!path2) {
    return "";
  }
  const paramQueue = [...params];
  const usedKeys = /* @__PURE__ */ new Set();
  return path2.split("/").map((segment) => {
    for (let i = 0; i < paramQueue.length; i++) {
      const [key, value] = paramQueue[i];
      if (segment === value && !usedKeys.has(key)) {
        usedKeys.add(key);
        return `:${key}`;
      }
    }
    return segment;
  }).join("/");
};
var prefixRouterPathMiddleware = (path2, router) => {
  const MIDDLEWARE_NAME = "prefixRouterPathMiddleware";
  path2 = path2.replace(/\/$/, "");
  router.stack = router.stack.filter((layer) => layer.name !== MIDDLEWARE_NAME);
  router.use((req, res, next) => {
    req["subPath"] = req["subPath"] ? req["subPath"] + path2 : path2;
    next();
  });
  const middlewareLayer = router.stack.pop();
  if (middlewareLayer) {
    middlewareLayer.name = MIDDLEWARE_NAME;
    router.stack.unshift(middlewareLayer);
  }
};
var responseTimeMetricsMiddleware = (serviceUtils, legacyPathNaming) => {
  const requestDuration = {
    type: "Histogram" /* HISTOGRAM */,
    name: "express_router_request_duration_seconds",
    help: "request duration handled by router in seconds",
    buckets: [0.01, 0.05, 0.1, 0.3, 1],
    labels: {
      names: ["service", "path", "method", "status"]
    }
  };
  const responseTimeMetric = serviceUtils.metrics.createMetric(requestDuration);
  serviceUtils.logger.info("responseTimeMetric", responseTimeMetric.labels);
  return (req, res, next) => {
    const endTimer = responseTimeMetric.startTimer();
    const originalEnd = res.end;
    res.end = (...args) => {
      var _a;
      let path2 = ((_a = req.route) == null ? void 0 : _a.path) && req.route.path !== "*" ? req.route.path : "/";
      if (req.subPath) {
        path2 = path2 === "/" ? req.subPath : req.subPath + path2;
      } else if (req.baseUrl) {
        path2 = _replacePathWithPlaceholders(
          req.baseUrl + path2,
          Object.entries(req.params ?? [])
        ).replace(/\/$/, "");
      }
      if (!path2 || !req.route) {
        path2 = req.subPath ?? "/";
      }
      if (legacyPathNaming) {
        path2 = path2.replace(/\/:/g, "/--").replace(/^\//, "").replace(/[/?]+$/, "");
        path2 = path2 || "root";
      }
      endTimer({
        service: serviceUtils.config.service_name,
        path: path2,
        method: req.method,
        status: res.statusCode
      });
      originalEnd.apply(res, args);
    };
    next();
  };
};

// src/trace.ts
import { v1 as uuidv1 } from "uuid";
var X_REQUEST_HEADER = "x-request-id";
var extractTraceContext = (headers) => {
  const _headers = new Headers(headers);
  const newHeaders = new Headers({
    "x-request-id": _headers.get("x-request-id") ?? uuidv1()
  });
  ["traceparent", "tracestate"].forEach((key) => {
    const value = _headers.get(key);
    if (value) {
      newHeaders.set(key, value);
    }
  });
  return newHeaders;
};

// src/open_telemetry.ts
import {
  propagation
} from "@opentelemetry/api";
import { v1 as uuidv12 } from "uuid";
var XRequestPropagator = class {
  /**
   * Injects values from a given `Context` into a carrier.
   *
   * OpenTelemetry defines a common set of format values (TextMapPropagator),
   * and each has an expected `carrier` type.
   *
   * @param {Context} context the Context from which to extract values to transmit over
   *     the wire.
   * @param {unknown} carrier the carrier of propagation fields, such as http request
   *     headers.
   * @param {TextMapSetter} setter an optional {@link TextMapSetter}. If undefined, values will be
   *     set by direct object assignment.
   */
  inject(context, carrier, setter) {
    var _a, _b;
    setter.set(
      carrier,
      X_REQUEST_HEADER,
      ((_b = (_a = propagation.getBaggage(context)) == null ? void 0 : _a.getEntry(X_REQUEST_HEADER)) == null ? void 0 : _b.value) ?? uuidv12()
    );
  }
  /**
   * Given a `Context` and a carrier, extract context values from a
   * carrier and return a new context, created from the old context, with the
   * extracted values.
   *
   * @param {Context} context the Context from which to extract values to transmit over
   *     the wire.
   * @param {unknown} carrier the carrier of propagation fields, such as http request
   *     headers.
   * @param {TextMapGetter} getter an optional {@link TextMapGetter}. If undefined,
   *     keys will be all own properties, and keys will be accessed by direct object access.
   * @return {Context} context
   */
  extract(context, carrier, getter) {
    const headers = getter.get(carrier, X_REQUEST_HEADER);
    const xRequestHeader = Array.isArray(headers) ? headers[0] : headers;
    if (!xRequestHeader) {
      return context;
    }
    let baggage = propagation.getBaggage(context) ?? propagation.createBaggage();
    baggage = baggage.setEntry(X_REQUEST_HEADER, { value: xRequestHeader });
    return propagation.setBaggage(context, baggage);
  }
  fields() {
    return [X_REQUEST_HEADER];
  }
};

// src/index.ts
var _yargs = (...args) => (
  // Defaults that are described are infered from c12 and not a `default` property
  yargs(...args).usage("Usage: $0 [command] [options]").options({
    "config-directory": {
      alias: "d",
      describe: "Absolute or relative path of the config file. Defaults to cwd",
      type: "string",
      nargs: 1,
      global: true
    },
    "config-file": {
      alias: "f",
      describe: "Name of the config file with or without the extension. Defaults to service-utils.config`",
      type: "string",
      nargs: 1,
      global: true
    },
    config: {
      alias: "c",
      describe: "Absolute or relative path of the config file with or without extension. Defaults to ${cwd}/service-utils.config",
      type: "string",
      nargs: 1,
      global: true
    }
  }).help("h").alias("h", "help")
);
_yargs(hideBin(process.argv)).parseSync();
var ServiceUtils = class _ServiceUtils {
  config;
  logger;
  metrics;
  prometheusServer;
  /**
   * Creates the logger, metrics, and prometheus metrics endpoint
   *
   * @param config
   */
  constructor(config) {
    this.config = config;
    this.logger = _ServiceUtils.createLogger(config);
    if (config.metrics instanceof Array) {
      config.metrics = config.metrics[0];
    }
    if (config.metrics) {
      this.prometheusServer = _ServiceUtils.createPrometheusServer(
        config.metrics,
        { service: config.service_name ?? "default_service" }
      );
    }
    this.metrics = _ServiceUtils.createMetrics(config, this.logger);
  }
  static createPrometheusServer(prometheus_config, defaultLabels) {
    return new PrometheusServer(prometheus_config, defaultLabels);
  }
  static createLogger(config) {
    return createWinstonLogger(
      config.service_name ?? "default_service",
      config.logging
    );
  }
  static createMetrics(config, logger) {
    return new Metrics(
      config.service_name ?? "default_service",
      logger,
      config.metrics
    );
  }
  async teardown() {
    if (this.prometheusServer) {
      await this.prometheusServer.close();
    }
  }
  /**
   * @param {Object=} options c12 loadConfig configuration
   * @param {Object=} options.defaultConfig Default config overrideable from yaml
   * @param {string=} options.envName Environment-conditional to load
   * @param {string=} options.configDirectory Default config directory overrideable in cli. Overrides c12's options.cwd
   * @param {string=} options.configFile Name of the config file (without extension) overrideable in cli. Defaults to service-utils.config
   * @return
   */
  static async loadConfig(options) {
    const parsedArgs = _yargs(hideBin(process.argv)).parseSync();
    let configDirectory;
    let configFile;
    if ((options == null ? void 0 : options.useArgs) !== false) {
      if (parsedArgs.config) {
        const configPath = path.parse(parsedArgs.config);
        configDirectory = configPath.dir;
        configFile = configPath.name;
      }
      configFile ??= parsedArgs.configFile ?? (options == null ? void 0 : options.configFile);
      configDirectory ??= parsedArgs.configDirectory ?? (options == null ? void 0 : options.configDirectory) ?? (options == null ? void 0 : options.cwd);
      if (configDirectory && !/^\//.test(configDirectory)) {
        configDirectory = path.resolve(
          `${process.cwd()}/${configDirectory ?? ""}`
        );
      }
    }
    const loadedConfig = await loadConfig({
      name: "service-utils",
      ...options,
      ...{
        cwd: configDirectory,
        configFile
      }
    });
    return loadedConfig.config;
  }
};
var singleton;
var getInstance = async (options) => {
  if (singleton === void 0) {
    const loadedConfig = await ServiceUtils.loadConfig(options);
    singleton = new ServiceUtils(loadedConfig);
    if ((options == null ? void 0 : options.startPrometheusServer) !== false && singleton.prometheusServer) {
      singleton.prometheusServer.start();
    }
  }
  return singleton;
};
var teardown = async () => {
  if (singleton !== void 0) {
    await singleton.teardown();
    singleton = void 0;
  }
};
var helpers = {
  wrapExpressRouteHandlers: wrapRouteHandlers,
  prefixRouterPathMiddleware,
  extractTraceContext,
  responseTimeMetricsMiddleware,
  XRequestPropagator
};
var prometheus = Prometheus3;
export {
  ServiceUtils,
  getInstance,
  helpers,
  prometheus,
  teardown
};
//# sourceMappingURL=index.mjs.map