import * as express from 'express';
import { loadConfig } from 'c12';
import winston, { Logger } from 'winston';
import Prometheus from 'prom-client';
import HTTP from 'http';
import { TextMapPropagator, Context, TextMapSetter, TextMapGetter } from '@opentelemetry/api';

declare const logLevels: {
    fatal: number;
    error: number;
    warn: number;
    info: number;
    http: number;
    verbose: number;
    debug: number;
    trace: number;
    silly: number;
};
type Level = keyof typeof logLevels;
/**
 * Configurable and serializable Winston logger options
 * to be derived into its associated objects with {@link createWinstonLogger}
 */
interface WinstonLoggerOptions {
    level?: Level;
    stacktrace?: boolean;
    format?: keyof typeof winston.format | 'ecs';
    formatOptions?: any;
    transports?: Array<{
        transport: 'File' | 'Console' | 'Http' | 'Stream';
        options?: {
            format?: keyof typeof winston.format | 'ecs';
            [key: string]: any;
        };
    }>;
    defaultMeta?: {
        [key: string]: any;
    };
}

/**
 * @deprecated Legacy code from service-runner
 */

declare enum MetricTypeEnum {
    GAUGE = "Gauge",
    HISTOGRAM = "Histogram",
    COUNTER = "Counter",
    SUMMARY = "Summary",
    TIMING = "Histogram"
}
/**
 * @deprecated Use {@link Metrics.createMetric} to avoid using this interface.
 *
 * These options are for the specific metric being measured.
 *
 * @example
 * {
 *   type: 'Counter',
 *   name: 'hitcount',
 *   prometheus: {
 *     name: 'hitcount',
 *     help: 'hit count',
 *     staticLabels: {},  // a key-value pair of labels
 *     buckets: [], // https://github.com/siimon/prom-client#histogram
 *     percentiles: [], // https://github.com/siimon/prom-client#summary
 *   },
 *   sampleRate: 1, // default 1 https://github.com/brightcove/hot-shots/blob/v6.3.0/README.md#usage
 *   labels: {
 *     names: [],
 *     labelPosition: 'before',
 *     omitLabelNames: false
 *   }
 * }
 */
interface MetricOptions {
    type: MetricType;
    /**
     * Metrics are cached by this name, as opposed to makeRawMetrics
     * where it's cached by the Prometheus metrics name
     */
    name: string;
    prometheus: {
        name: string;
        help: string;
        staticLabels?: Record<string, string>;
        buckets?: Array<number>;
        percentiles?: Array<number>;
    };
    sampleRate?: number;
    labels?: {
        names: Array<string>;
        labelPosition?: string;
        omitLabelNames?: boolean;
    };
}
/**
 * @deprecated Use {@link Metrics.createMetric} to use Prometheus directly.
 *
 * This class is a wrapper to call metrics functions
 */
declare class Metric {
    type: MetricType;
    metric: PrometheusMetric;
    logger: Logger;
    constructor(client: PrometheusClient, logger: Logger, options: MetricOptions);
    increment(amount?: number, labels?: Array<string>): void;
    decrement(amount?: number, labels?: Array<string>): void;
    observe(value: number, labels?: Array<string>): void;
    gauge(amount: number, labels?: Array<string>): void;
    set(value: number, labels?: Array<string>): void;
    timing(value: number, labels?: Array<string>): void;
    endTiming(startTime: number, labels?: Array<string>): void;
}

/**
 * @deprecated Use {@link Metrics.createMetric} to use Prometheus directly.
 *
 * Prometheus metrics implementation
 */
declare class PrometheusMetric {
    options: MetricOptions;
    client: typeof Prometheus;
    staticLabels: any;
    metric: Prometheus.Metric;
    constructor(options: MetricOptions, client: typeof Prometheus);
    /**
     * Gets label values array for this metric
     * including both static and dynamic labels merged together.
     *
     * @param {Array} labelValues
     * @return {Array}
     */
    _getLabelValues(labelValues: Array<string>): string[];
    increment(amount: number, labelValues: Array<string>): void;
    decrement(amount: number, labelValues: Array<string>): void;
    observe(value: number, labelValues: Array<string>): void;
    gauge(amount: number, labelValues: Array<string>): void;
    set(value: number, labelValues: Array<string>): void;
    timing(value: number, labelValues: Array<string>): void;
    endTiming(startTime: number, labelValues: Array<string>): void;
}
/**
 * @deprecated Use {@link Metrics.createMetric} to use Prometheus directly.
 */
declare class PrometheusClient {
    logger: Logger;
    client: typeof Prometheus;
    constructor(logger: Logger);
    makeMetric(options: MetricOptions): PrometheusMetric;
    close(): void;
}

interface PrometheusMetricsConfig {
    type: 'prometheus';
    port: number;
    name?: string;
    collectDefaultMetrics?: boolean;
}
declare class PrometheusServer {
    config: PrometheusMetricsConfig;
    server: HTTP.Server;
    constructor(config: PrometheusMetricsConfig, defaultLabels?: Record<string, string>);
    start(): void;
    close(): Promise<void>;
}

type MetricType = MetricTypeEnum | `${MetricTypeEnum}`;
type GenericPrometheusMetricsConfig<T extends MetricType> = ConstructorParameters<typeof Prometheus[T]>[0];
type RawMetricOptions<T extends MetricType> = GenericPrometheusMetricsConfig<T> & {
    type: T;
    [key: string]: any;
};
declare class Metrics {
    options: PrometheusMetricsConfig | undefined;
    client: PrometheusClient;
    prometheus: typeof Prometheus;
    serviceName: string;
    cache: Map<string, Metric>;
    logger: Logger;
    constructor(serviceName: string, logger: Logger, options?: PrometheusMetricsConfig);
    getServiceName(): string;
    getServiceLabel(): {
        service: string;
    };
    /**
     * @deprecated Remnant from service-runner. Use Prometheus directly.
     */
    fetchClient(): PrometheusClient;
    /**
     * @deprecated Use {@link createMetric} for new projects.
     *
     * @param options
     * @return
     */
    makeMetric(options: MetricOptions): Metric;
    /**
     * Makes and returns a raw Prometheus Metric bypassing the service-runner wrapper.
     *
     * @param options
     * @return
     */
    createMetric<T extends MetricType>(options: RawMetricOptions<T>): InstanceType<typeof Prometheus[T]>;
    close(): void;
}

/**
 * @experimental
 * Propagates `x-request-id` headers. Used with OpenTelemetry.
 */
declare class XRequestPropagator implements TextMapPropagator {
    /**
     * Injects values from a given `Context` into a carrier.
     *
     * OpenTelemetry defines a common set of format values (TextMapPropagator),
     * and each has an expected `carrier` type.
     *
     * @param {Context} context the Context from which to extract values to transmit over
     *     the wire.
     * @param {unknown} carrier the carrier of propagation fields, such as http request
     *     headers.
     * @param {TextMapSetter} setter an optional {@link TextMapSetter}. If undefined, values will be
     *     set by direct object assignment.
     */
    inject(context: Context, carrier: unknown, setter: TextMapSetter): void;
    /**
     * Given a `Context` and a carrier, extract context values from a
     * carrier and return a new context, created from the old context, with the
     * extracted values.
     *
     * @param {Context} context the Context from which to extract values to transmit over
     *     the wire.
     * @param {unknown} carrier the carrier of propagation fields, such as http request
     *     headers.
     * @param {TextMapGetter} getter an optional {@link TextMapGetter}. If undefined,
     *     keys will be all own properties, and keys will be accessed by direct object access.
     * @return {Context} context
     */
    extract(context: Context, carrier: unknown, getter: TextMapGetter): Context;
    fields(): string[];
}

interface _Config {
    service_name?: string;
    logging?: WinstonLoggerOptions;
    metrics?: PrometheusMetricsConfig;
    [key: string]: any;
}
type Config<T extends Record<string, any>> = _Config & T;
declare class ServiceUtils<T extends Record<string, any> = object> {
    config: Config<T>;
    logger: winston.Logger;
    metrics: Metrics;
    prometheusServer?: PrometheusServer;
    /**
     * Creates the logger, metrics, and prometheus metrics endpoint
     *
     * @param config
     */
    constructor(config: Config<T>);
    static createPrometheusServer(prometheus_config: PrometheusMetricsConfig, defaultLabels: Record<string, string>): PrometheusServer;
    static createLogger(config: Config<Record<string, any>>): winston.Logger;
    static createMetrics(config: Config<Record<string, any>>, logger: winston.Logger): Metrics;
    teardown(): Promise<void>;
    /**
     * @param {Object=} options c12 loadConfig configuration
     * @param {Object=} options.defaultConfig Default config overrideable from yaml
     * @param {string=} options.envName Environment-conditional to load
     * @param {string=} options.configDirectory Default config directory overrideable in cli. Overrides c12's options.cwd
     * @param {string=} options.configFile Name of the config file (without extension) overrideable in cli. Defaults to service-utils.config
     * @return
     */
    static loadConfig<T extends Record<string, any>>(options?: Parameters<typeof loadConfig<Config<T>>>[0] & {
        useArgs?: boolean;
        configDirectory?: string;
    }): Promise<Config<T>>;
}

/**
 * @param {Object=} options c12 loadConfig configuration
 * @param {Object=} options.defaultConfig Default config overrideable from yaml
 * @param {string=} options.envName Environment-conditional to load
 * @param {string=} options.configDirectory Default config directory overrideable in cli
 * @param {string=} options.configFile Name of the config file (with or without extension) overrideable in cli. Defaults to service-utils.config
 * @param {false=} options.startPrometheusServer Starts Prometheus server if not set to false
 * @param {true=} options.useArgs Use yaml config fetched from cli args to override config if not set to false. Useful for testing.
 * @return {ServiceUtils}
 */
declare const getInstance: <T extends Record<string, unknown>>(options?: Parameters<typeof loadConfig<Config<T>>>[0] & {
    startPrometheusServer?: boolean;
    useArgs?: boolean;
}) => Promise<ServiceUtils<T>>;
declare const teardown: () => Promise<void>;
declare const helpers: {
    wrapExpressRouteHandlers: (app: express.Express | express.Router, metrics: Metrics, subPath?: string) => void;
    prefixRouterPathMiddleware: (path: string, router: express.Router) => void;
    extractTraceContext: (headers: HeadersInit) => Headers;
    responseTimeMetricsMiddleware: (serviceUtils: ServiceUtils, legacyPathNaming?: boolean) => (req: any, res: any, next: any) => void;
    XRequestPropagator: typeof XRequestPropagator;
};
declare const prometheus: typeof Prometheus;

export { type MetricType, MetricTypeEnum, ServiceUtils, getInstance, helpers, prometheus, teardown };
